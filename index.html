<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <script>

// var request =new XMLHttpRequest()
// request.open("GET",...,true)
// request.send()

//  request.onload = function(){
//     var data=JSON.parse(request.response)
//     console.log(data)
// }

// while
// *************


// var i= 0
// while(i<5){
//     console.log(i)
//     i++
// }
    
// for loop
// *************

// for(let i=0;i<5;i++){
//    console.log('number'+i )
    
// }
// // 

// const name =["mani","ram", "vani"]

// for(i=0;i<name.length;i++){
//     console.log(name[i])
// }


// // for in loop
// ***************

// for in applicable to object key value based and array based. 

// let obj = {
//    name = "guvi",
//    age = " 20 "
// }

// for(var i in obj){
  
//   console.log(i,obj[i])
// }

// template literal

// let a=10
// let b =20
// console.log (`fifteen is ${a+b}and not ${a*b}`)
// console.log('fifteen is'+(a+b)+'and not'(a*b)+'.')
// let color =["red","yellow","green"]

// for(let key in color){

//     // console.log(key)
//     console.log(color[key])
// }





// // for in loop
// ****************************

// let a = document.getElementsByTagName("div")

// for (var i in a){
//   console.log(a[i])
// }



// const person ={
//     name: "ram",
//     age: "20",
//     color:"white"
// }

// for( let key in person){

//     console.log(person[key])
// }



//  for else loop
// *****************
// const age=15

// if(age>18){
//     console.log("you can vote")
// }else{
//     console.log("you can not vote")
// }

 // forEach loop
//  *****************
//  syntax: arr.forEach((ele=>(console.log(ele)))
// it will applicable onely to array
// it will  take function as parameter
// will also apply on each and every element of array
// return type is undefined
// *************
// let name =["mani","ram","guvi","saras"]
// name.forEach((ele)=>(console.log(ele)))

// const name = ["ram","sita","karna","pandav"]

// name.forEach(callBack);
//     function callBack(item,index,array){
//     console.log(item,index,array)
// }

// const numbers =[1,2,3,4,5]

// let sum =0;

// numbers.forEach(item=>{

//     sum + = item;
// })
// console.log (sum)

// for of loop
//  *****************
//  only for forward iteration
// print elements in the array for variable of arrayname
// syntax: for(variable of array name)
// do not applicable to object or key value based

// let arr =[1,2,3,4,5]

// for (let i of arr){
//   console.log(i)
// }

// currying or nested function
// ******************************

// function calABC(a){
//   return function(b){
//     return function(c){
//       return a+b+c
//     }
//   }
// }

// console.log(calABC(1)(2)(3))


// copy by value
// ********************
// var a=10
// var b =a  /* copy by value only for primitive data type. used less memory*/
// a=20
// console.log(a,b)

// copy by Reference
// ********************

//  Spread operator
// ********************

// let arr=["guvi","geek"]
// console.log(arr) /*  
// 0: "guvi"
// 1: "geek"
// length: 2    */

// console.log(...arr)  /* guvi geek Â ['guvi', 'geek']     */

// let str = "hello"
// console.log(...str)   /* h e l l o   */


// let str = "hello"
// console.log(str)
// console.log(...str)
// let chr =[...str] 
// console.log(chr)  
//  /* Array(5)
// 0: "h"
// 1: "e"
// 2: "l"
// 3: "l"
// 4: "o"
// length: 5   */

// let a = [1,2,3]
// let b =[4,5,6]
// let c =[...a,...b]

// console.log(c)
// console.log([c])

// let a = [1,2,3]
// let b =[4,5,6]
// a.push(...b);
// console.log(a)
// console.log([a])

  // REST PARAMETERS
// ********************

// /* can pass any no. of parameters in the function  - optimised*/

// function calcu(...item){

//   console.log(item)
//   let sum =0
//   for (i=0;i<item.length;i++){
//     sum=sum+item[i]
    
//   } return sum
// }

// console.log(calcu(10,20,30))


 // ARRAY DESTRUCTURING
// ********************

 /* Unpacking array elements in to bunch of variables*/

// let arr=["mani","ram"]

// let[fname,lname] =arr

// console.log(fname,lname)
// console.log([fname])

// let [fname,,,lname]=["mani","ram","guvi","saras"]
// console.log(fname,lname)


// SET Time Out : is a method having two parameters. One is function and another
// one is number millisecond

// setTimeout(function(){

//   console.log("1. App start")
// },3000)

// setTimeout(function(){

// console.log("2. App start")
// },2000)

// CALLBACK callback Quee,call stack,webserver
// to convert a non-blocking code in to blocking code we using the concept called callBack.
// Also the function simply accepts another function as parameter
// that parameter function is nothing but called as callback function
// only for short asyn operation.
// Ex. setTimeout(() => {
  
// }, timeout);


// Js is Non-blocking code;
// it is asyncronous code;
// it is single threaded language;
// call back used only for short async operations set time out.


// syntax:
// function execute(value1,value2,cb){
// setTimeout(function(){
//   var result = value1+value2
//   cb(result)

// },5000)
  
// }
// execute(10,5, function(resultData){
//   console.log(resultData)
// })


// call back hell - nested structure. we donot use larger functions only for short async function

// function f1{
//   function f2{
//     function f3{
//       function f4{
//         function f5{
 //        console.log("Done")
//         }
//       }
//     }
//   }
// }

// promise - fetch
// ****************
// promise return data type is object
// return an object result of async operation
// why promise: to overcome from the callback hell in js.
// 3 states : pending,resolved,rejected
// initial state pending when we create promise

// pending to fullfilled when complete an asyn operation successfully(resolve)
// pendng to rejected when async oper fails.(reject)

// syntax is variable name= new Promise()
// this object has function as parameter
// inside the function we have resolve and reject

// .then is access the success of the resolved state
// .catch is access the failiure of the rejected state
// output of the promise is object
//  to access the result of promise we use .then and .catch

// advantages of Promise
// it return always the promise.
// usage of promise is return type of function 
// can use to handle multiple async function operation.

// disadvantage promise chain

// function foo(){ 
//   return new promise((resolve,reject)=>{
//     resolve ("this is resolved")
//     reject("this is rejected")

//   })
// }foo().then((data)=>{console.log(data)}).catch((error)=>{console.log(error)})

// function foo(){ 
//   return new promise((resolve,reject)=>{
//     setTimeout(() => {

//       resolve("Hello Mani")
      
//     }, 4000);

//   })
// }foo().then((data)=>{console.log(data)}).catch((error)=>{console.log(error)})


// let res =fetch("url")
// console.log(res)
// res.then((data)=>{return data.json()})
// .then((data)=>console.log(data)).catch((error)=>console.log(error))

// function foo(){

//   console.log(data)
//   console.log(data.TN.district.chennai)
// }

// function foo(data){

//   for(var i in data){
//     console.log(`confirmed:${data[i].confirmed) Active: ${data[i].Active}`)
//   }
// }

// Promise chain
// *****************
// function mul(num){
//   return new Promise((resolve, reject)=>{

//   setTimeout(() => {
//     resolve(2*num)},2000)
    
//   });
// }
// mul(5).then((v1)=>{console.log(v1)
//   return mul(v1)}).then((v2)=>{console.log(v2);
//   return mul(v2)}).then((v3)=>{console.log(v3);
//   return mul(v3)})
//   // .catch((error)=>{console.log(error)}
// syntax:
// fetch("url").then(function(data){
//   console.log(data)}).catch(function(error){console.log(error)})

//  fetch("url");
//  .then (function(data){
//    return data.json()
//  }).then(function(dataObj){
// var list = document.getElementById("list")
// dataObj.forEach(element=>{
// var li =document.createElementById("li")
// li.innerText =element.productName
// list.appendChild("li")

// })
//  })
// .catch(function(error){
//   console.log(error)
// })

// function calculateAge(year){

//   return newPromise(function(resolve,reject){/*pemdimg*/
//         setTimeout(function(){
//           var today = new Date()
//           var age =today.getFullYear()-year
//           if(age<18){
//             resolve(age)
//           }else{
//             reject("no eligible")
//           }

//         },3000)

//   })
// }
// calculateAge(2021).then (function(data){

//   console.log(data)

// }).catch(function(error){console.log(error)})

// var a=4
// let p1 = new Promise((resolve,reject)=>{
//   if (a>3){
//     resolve("app start 1")
//   }else{
//     reject ("app end 2")
//   }
// })
//  console.log(p1)
// console.log(3)

// async await function
// ***************************
// async function getAllData(){
//   try{
//     var data = await fetch("url")
//     var obj = await data.json()
//     console.log(obj)

// }catch(error){
//   console.log(error)
// }
// }


// CRUD OPERATION
// ***************************

// Create   Get
// Read     Post
// Update   Put
// Delete   Delete


//  document. getElementById
//  document.getElementsByClassName
//  document.getElementsByTagName

// already hrml elements are there we are supposed to print those elements in console
// The elements must be in html file. otherwise it will not work.

// query selector vs query selector getAllData

// based upon the selector the first occurance of the selector

// Query selector all will retrive all the elements whose selctor must be 
// there. out put will be an array

// let a = document.querySelectorAll(`.main`)
// console.log(a)

// using append we can add multiple elements
// the return type of append is always undefined

// using appendchild we can add only one Element
// the return type of append child is added element.Element

// function foo(){

//   console.log ("Hello")
// }
// foo()


// let res =document.getElementsByTagName('button').addEventListener('click', foo)

// function foo(){
//   let result = document.getElementsById('name').value
//   console.log(result)
// }
// foo()

// let button = document.createElement('button')
// button.innerHTML ="click"
// button.addEventListener('click',foo)
// document.body.append(button)

// function foo(){
//   var div = document.createElement('div')
//   div.innerHTML ="this is div"
//   div.style.color = "green" 
//   div.style.fontSize = "30px"
//   document.body.append(div)
// }

// // innerText is just create a Text
// // inner HTML create a element

// document.querySelector('div').addEventListener('mouseover',foo)

// function foo(event){
//   var p = document.createElement('p')
//   p.setAttribute('class','text-primary')
//   p.innerHTML =`client X:${event.clientX} and client Y: ${event.clientY}`
//   document.body.append(p)
// }


// document.querySelector('button').addEventListener('click',foo)

// function foo(){
  
//   let res =prompt("enter any value")
//   let p = document.createElement('p')
//   p.innerHTML =res
//   p.style.fontSize ="30px"
//   document.body.append(p)
// }



// var span =document.createElement('span')
// span.innerHTML ="this is span"
// span.addEventListener('mouseover',foo)
// document.body.append(span)

// var br =document.createElement('br')
// document.body.appendChild(br)

// function foo(){

//   document.querySelector('span').style.color ="red"

// }

// var inp = document.createElement('input')
// inp.setAttribute('type','textarea')
// document.body.append(inp)

// MRF - Map,Reduce,Filter - inbuild functions only can use for array.
 
// Map 
// will applicable only to array
// will take fuction as parameter
// will apply to each and every element of the array
// it will return the new array.Filter

// function taken the element as parameter
// result is new array

// syntax: array.map(function)

// if no function is passed it will throw error. output is undefined
// *******************************************************************************

// let arr = [1,2,3,4]
// let result = arr.map((element)=>element*2)
// console.log(result)

// accessing the marks by increase 10
// ************************************************

// let stud = [{name:"mani",marks:"50"},{name: "Ram",marks: "60"}]

// var res = stud.map((element)=>{
//   element.marks+10
// return element})
// console.log(res)

// let stud = [{name:"mani",marks:"50"},{name: "Ram",marks: "60"},{name:"sita",marks:"40"}]

//  var res = stud.filter((item)=>{
//  if (item.marks>50)
//   return item})
// console.log(res)

// var res = stud.filter((item)=>item.marks>50).map((item)=>item.name)
// console.log(res)

// Reduce
// **************

// reduce will reduce entire array in to single values
// syntax: array name.reduce(function)
// acc- accumulator it will take first index value as parameter
// ele- Element

// if acc not defined

// let arr=[1,2,3,4]
// let sum = arr.reduce((acc,item)=>acc+item,100)
// console.log(sum)

// if acc not defined - acc will take as initial value. change the array in to single value

// DOM
// ****************

// TO create HTML elements dynamically by using Js.
// operations: all are methods(inbuilt)in Js only

// How to create elements dynamically ?

// only html elements
// Element: combination of tag+content
// content: to add content use inner HTML
// to add the tag in body of HTML file.HTML
// document.body.append(variable name)

// How to add attribute to an HTML Element

// class,id, href...


// var paragraph = document.createElement('p')
// paragraph.innerHTML ="this is p"
// document.body.append(paragraph)





// SetAttribute:
// * **************

// two parameters
// 1st parameter class,id, selectors
// 2nd parameter class name/id name
// Example
// <div class="main">this is SetAttribute</div>



// var input = document.createElement('input')
// input.setAttribute('type','text')
// input.setAttribute('name','text')
// input.setAttribute('id','text')
// document.body.append(input);

// arrow function

// var res = functio(a){
//   return a+"Hello guvi";
// }

// res("Hi");

// // var res = (a)=>a+"hello guvi"
// // console.log(res("hi"));

// // // 
// ARRAY OF DESTRUCTURING: ARRAY elements separated in to separate variable.

strongly typed programming language that build on JS. 
Typescript add additional syntax to js.
which runs anywhere js run in the browser without additional coding.

Template literal: are literal delimited with backticks~ allowing embedded expressions

copy by value Vs copy by reference:

Anonymous function:

can be declared with multiple input, but only one output.
also it can be declared without any names

iife:
cannot access outside the function.execute the function immediately.
help use memory efficiently. it prvent global scope getting polluted.



</script>  
</body>
</html>